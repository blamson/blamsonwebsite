---
title: 'Named Entity Recognition: A Transformers Tutorial'
author: Brady Lamson
date: '2024-01-18'
slug: named-entity-recognition-a-transformers-tutorial
categories: []
tags: []
description: ~
image: images/hugs.png
math: ~
license: ~
hidden: no
comments: no
toc: yes
output:
  blogdown::html_page:
    toc: true
---


<div id="TOC">
<ul>
<li><a href="#overview-and-motivation" id="toc-overview-and-motivation">Overview and Motivation</a>
<ul>
<li><a href="#named-entity-recognition" id="toc-named-entity-recognition">Named Entity Recognition</a></li>
<li><a href="#fine-tuning" id="toc-fine-tuning">Fine Tuning</a></li>
<li><a href="#downstream-tasks" id="toc-downstream-tasks">Downstream Tasks</a></li>
</ul></li>
<li><a href="#overall-structure" id="toc-overall-structure">Overall Structure</a>
<ul>
<li><a href="#the-trainer" id="toc-the-trainer">The Trainer</a></li>
</ul></li>
<li><a href="#the-dataset" id="toc-the-dataset">The Dataset</a>
<ul>
<li><a href="#loading-the-data" id="toc-loading-the-data">Loading the Data</a>
<ul>
<li><a href="#what-is-this-thing" id="toc-what-is-this-thing">What is this thing?</a></li>
</ul></li>
<li><a href="#example-row-format" id="toc-example-row-format">Example Row Format</a></li>
<li><a href="#ner-label-formats" id="toc-ner-label-formats">NER Label Formats</a>
<ul>
<li><a href="#quick-glimpse-at-other-common-formats" id="toc-quick-glimpse-at-other-common-formats">Quick glimpse at other common formats:</a></li>
</ul></li>
<li><a href="#wait-my-data-doesnt-look-like-yours" id="toc-wait-my-data-doesnt-look-like-yours">Wait, my data doesn‚Äôt look like yours!</a></li>
<li><a href="#tokenizing-the-data" id="toc-tokenizing-the-data">Tokenizing the Data</a>
<ul>
<li><a href="#example-tokenization" id="toc-example-tokenization">Example Tokenization</a></li>
<li><a href="#applying-tokenizer-and-realigning-labels" id="toc-applying-tokenizer-and-realigning-labels">Applying Tokenizer and Realigning Labels</a></li>
<li><a href="#sanity-checks" id="toc-sanity-checks">Sanity Checks</a></li>
</ul></li>
</ul></li>
<li><a href="#building-the-trainer" id="toc-building-the-trainer">Building the Trainer</a>
<ul>
<li><a href="#imports" id="toc-imports">Imports</a></li>
<li><a href="#data-collator" id="toc-data-collator">Data Collator</a></li>
<li><a href="#evaluator-compute_metrics-function" id="toc-evaluator-compute_metrics-function">Evaluator: compute_metrics function</a></li>
<li><a href="#id-and-label-maps" id="toc-id-and-label-maps">Id and Label Maps</a></li>
<li><a href="#model-initializer" id="toc-model-initializer">Model Initializer</a></li>
<li><a href="#training-arguments" id="toc-training-arguments">Training Arguments</a></li>
<li><a href="#make-the-trainer" id="toc-make-the-trainer">Make the Trainer</a></li>
</ul></li>
<li><a href="#training-via-hyperparameter-search" id="toc-training-via-hyperparameter-search">Training via Hyperparameter Search</a>
<ul>
<li><a href="#hyperparameter-space" id="toc-hyperparameter-space">Hyperparameter Space</a></li>
<li><a href="#hyperparameter-search" id="toc-hyperparameter-search">Hyperparameter Search</a></li>
</ul></li>
<li><a href="#training-the-final-model" id="toc-training-the-final-model">Training the Final Model</a>
<ul>
<li><a href="#training-evaluation" id="toc-training-evaluation">Training Evaluation</a>
<ul>
<li><a href="#creating-log-dataframe" id="toc-creating-log-dataframe">Creating Log Dataframe</a></li>
<li><a href="#visualizing-logs" id="toc-visualizing-logs">Visualizing Logs</a></li>
</ul></li>
</ul></li>
<li><a href="#using-the-model-finally" id="toc-using-the-model-finally">Using the Model (Finally)</a>
<ul>
<li><a href="#building-the-pipeline" id="toc-building-the-pipeline">Building the Pipeline</a></li>
</ul></li>
<li><a href="#test-split-evaluation" id="toc-test-split-evaluation">Test Split Evaluation</a></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul>
</div>

<div id="overview-and-motivation" class="section level1">
<h1>Overview and Motivation</h1>
<p>Here I‚Äôll be showing a standard workflow for fine tuning a large language model using the <code>transformers</code> library in Python. I‚Äôll be fine tuning for the specific downstream task of <strong>named entity recognition</strong>, though many things in this setup will work for other tasks as well.</p>
<p>There are many sources online for this topic, but I found myself extremely overwhelmed by all of the information when first learning how to do this. My goal here is to consolidate all of that information and add in a lot of my own thoughts along the way to hopefully help make this area less overwhelming.</p>
<p>In terms of knowledge coming in, this page is intended for a data scientist who is comfortable reading code and technical documentation. A basic understanding of machine learning and natural language processing is expected. I will be explaining much of the jargon, but not all of it.</p>
<p>For a repository to follow along with, I have a notebook that will be showing my process from start to finish. <a href="https://github.com/blamson/transformers_tutorial/blob/main/notebooks/transformers_tutorial.ipynb">&lt;Here is a link to that notebook&gt;</a>.</p>
<p>Our goal here is to take a pretrained large language model and have it extract specific ‚Äúentities‚Äù from a given text. To do that, we need to fine tune it for our specific needs. First off, what are these entities and what is named entity recognition?</p>
<div id="named-entity-recognition" class="section level2">
<h2>Named Entity Recognition</h2>
<p>Without going into too much detail, named entity recognition, or NER for short, is a type of token classification that allows for us to identify key parts of text. As an example, a model can predict which words in a sentence represent people, places, organizations, etc. The best way to explain NER is with a visual.</p>
<p><img src="images/ner_example.png" /></p>
<p>This is an extremely useful task, as being able to identify key parts of bulk text has a ton of applications. You can even choose what entities you want to identify so there‚Äôs a ton of creative freedom here. You could web scrape a site and easily extract the big names on its pages. From a tech tutorial example, you could use NER on a ton of writeups like these to see which packages and tools come up the most!</p>
<p>In particular this has a lot of applications in bulk messy text that you want classified. Being able to identify the date or company name of a giant text blob could be extremely useful for expediting some data processing. It‚Äôs never going to be perfect, but it can be extremely powerful.</p>
</div>
<div id="fine-tuning" class="section level2">
<h2>Fine Tuning</h2>
<p><strong>Fine tuning</strong> is simply a type of training you do to models that already exist. We don‚Äôt want to make a model from scratch, but most models by default aren‚Äôt capable of what we‚Äôre trying to do and aren‚Äôt going to be familiar with the type of data we‚Äôre using. Thus, we need to modify them a bit.</p>
<p>As an example, for this project we‚Äôll be using the distilibert-base-uncased model. To put it simply, it‚Äôs a smaller version of BERT that ignores capitalization. From the <a href="https://huggingface.co/distilbert-base-uncased">&lt;model docs&gt;</a> specifically:</p>
<blockquote>
<p><strong>Intended uses &amp; limitations</strong></p>
<p>You can use the raw model for either masked language modeling or next sentence prediction, but it‚Äôs mostly intended to be fine-tuned on a downstream task. See the <a href="https://huggingface.co/models?other=distilbert">&lt;model hub&gt;</a> to look for fine-tuned versions on a task that interests you.</p>
<p>Note that this model is primarily aimed at being fine-tuned on tasks that use the whole sentence (potentially masked) to make decisions, such as sequence classification, token classification or question answering. For tasks such as text generation you should look at model like GPT2.</p>
</blockquote>
</div>
<div id="downstream-tasks" class="section level2">
<h2>Downstream Tasks</h2>
<p><strong>Downstream Tasks</strong> are tasks like ‚Äúnamed entity recognition‚Äù, ‚Äútext classification‚Äù and other more niche language tasks. A better explanation is provided by <a href="https://www.baeldung.com/cs/downstream-tasks">&lt;Baeldung here in their overview on downstream tasks&gt;</a>. Here‚Äôs a relevant excerpt.</p>
<p><img src="images/downstream.png" /></p>
<p>So, our goal is to take our model of choice and get it used to our data and entities. To do that, we fine-tune the model! That‚Äôs the plan.</p>
</div>
</div>
<div id="overall-structure" class="section level1">
<h1>Overall Structure</h1>
<p>To execute on the plan we need to get the general gist of how to accomplish it. To do this I created a diagram that shows how all of the pieces fit together.</p>
<p>It may be a bit overwhelming at first but it proved to be an invaluable resource for me while learning. I recommend referring back to this as we progress.</p>
<p><img src="images/trainer_diagram.png" /></p>
<p>You may notice how the <code>trainer</code> is at the center of everything. Basically, the primary goal of using the standard transformers library is that everything plugs into the trainer object at the end. The bulk of the workflow is building and modifying all of the component pieces of the trainer. Once that‚Äôs done, doing any modifications is a cinch. So, we want to look at the trainer‚Äôs requirements and expectations so we can build our pieces around that. But what is the trainer?</p>
<div id="the-trainer" class="section level2">
<h2>The Trainer</h2>
<p><a href="https://huggingface.co/docs/transformers/main_classes/trainer">&lt;Documentation Link&gt;</a></p>
<p>To put it simply the Trainer is how we train our model. Wow. Helpful. To be more specific, the Trainer abstracts out the fine tuning process for us which saves us on a lot of work. It supports standard training, early stopping, grid search, specifying different optimization metrics and way more. So it strikes a good balance of abstraction while still giving you a lot of control over how it works. It is not required at all, but for a setup that uses it you‚Äôll want to revolve your designs around what it wants.</p>
<p>Referring back to the diagram, the trainer requires the following pieces:</p>
<ul>
<li>A dataset</li>
<li>A tokenizer</li>
<li>A data collator</li>
<li>A model initialization function</li>
<li>A hyperparameter space</li>
<li>Training arguments</li>
<li>A function for computing metrics</li>
<li>id2label dictionary</li>
</ul>
<p>Not all of these will be required for every project, but they are for my write up. As an example, a hyperparamter space is only required if you want to use the trainers hyperparameter search method.</p>
</div>
</div>
<div id="the-dataset" class="section level1">
<h1>The Dataset</h1>
<p>While the Trainer may be at the center, the data is the most important part of this process. Setting this up properly will be the difference between a model that performs excellently and one that is actually worse than the original one. As the mantra goes, garbage in garbage out. This section is more concerned with the structure of the dataset object specifically, setting up training data for NER is an enormous project on its own and is outside the scope of this page.</p>
<p>For this demonstration I‚Äôll be using the <a href="https://huggingface.co/datasets/conll2003">&lt;CoNLL2003 Dataset&gt;</a></p>
<blockquote>
<p>The shared task of CoNLL-2003 concerns language-independent named entity recognition. We will concentrate on four types of named entities: persons, locations, organizations and names of miscellaneous entities that do not belong to the previous three groups. The CoNLL-2003 shared task data files contain four columns separated by a single space. Each word has been put on a separate line and there is an empty line after each sentence. The first item on each line is a word, the second a part-of-speech (POS) tag, the third a syntactic chunk tag and the fourth the named entity tag. The chunk tags and the named entity tags have the format I-TYPE which means that the word is inside a phrase of type TYPE. Only if two phrases of the same type immediately follow each other, the first word of the second phrase will have tag B-TYPE to show that it starts a new phrase. A word with tag O is not part of a phrase. Note the dataset uses IOB2 tagging scheme, whereas the original dataset uses IOB1.</p>
</blockquote>
<p>This dataset conveniently contains all of the features I need for this tutorial. Obviously in the real world you‚Äôll need to put in a sizable amount of effort to getting labeled data and putting it into this format, but that‚Äôs outside the scope of this tutorial. I at least hope that showing what I‚Äôm working with and explaining what all the various features represent will help you understand what you‚Äôre aiming for and why.</p>
<div id="loading-the-data" class="section level2">
<h2>Loading the Data</h2>
<pre><code>In: 

from datasets import load_dataset

dataset = load_dataset(&quot;conll2003&quot;)
# Cut the training split in half for demonstration purposes. I AINT GOT ALL DAY
dataset[&quot;train&quot;] = dataset[&quot;train&quot;].train_test_split(test_size=0.5)[&quot;train&quot;]
dataset</code></pre>
<pre><code>Out:  

DatasetDict({
    train: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;pos_tags&#39;, &#39;chunk_tags&#39;, &#39;ner_tags&#39;],
        num_rows: 7020
    })
    validation: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;pos_tags&#39;, &#39;chunk_tags&#39;, &#39;ner_tags&#39;],
        num_rows: 3250
    })
    test: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;pos_tags&#39;, &#39;chunk_tags&#39;, &#39;ner_tags&#39;],
        num_rows: 3453
    })
})</code></pre>
<div id="what-is-this-thing" class="section level3">
<h3>What is this thing?</h3>
<p>So this is a <code>DatasetDict</code> that contains all of our splits as individual <code>Dataset</code> objects. This setup is designed to work very well with huggingface transformers and is what I‚Äôll be using for this demonstration. As for all the features, I‚Äôll explain those in a moment. If you need help figuring out how to use these objects. I‚Äôd check out <a href="https://huggingface.co/docs/datasets/index">&lt;the docs that can be found here&gt;</a>.</p>
</div>
</div>
<div id="example-row-format" class="section level2">
<h2>Example Row Format</h2>
<p>Many of these strings are quite long and result in messy output so I‚Äôll just show you a skeleton of what they look like individually.</p>
<pre><code>{
  &#39;id&#39;: int,
  &#39;tokens&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;foobar&#39;],
  &#39;pos_tags&#39;: [int, int, int],
  &#39;chunk_tags&#39;: [int, int, int],
  &#39;ner_tags&#39;: [int, int, int]
}</code></pre>
<p>Okay, so what is this? Let‚Äôs demystify the features a bit.</p>
<ul>
<li>id: It‚Äôs just the id. That‚Äôs it. An integer</li>
<li>tokens: A string broken up into its component parts. A list of strings.</li>
<li>pos_tags: Not sure and not relevant to this demonstration. We‚Äôll be dropping this.</li>
<li>chunk_tags: Not sure and not relevant to this demonstration. We‚Äôll be dropping this as well.</li>
<li>ner_tags: These integers represent the label assigned to each token. We can translate these numbers and get their labels.</li>
</ul>
<p>Let‚Äôs take a closer look at the <code>ner_tags</code>.</p>
<pre><code>In: dataset[&quot;train&quot;].features[&quot;ner_tags&quot;]
Out: Sequence(feature=ClassLabel(names=[&#39;O&#39;, &#39;B-PER&#39;, &#39;I-PER&#39;, &#39;B-ORG&#39;, &#39;I-ORG&#39;, &#39;B-LOC&#39;, &#39;I-LOC&#39;, &#39;B-MISC&#39;, &#39;I-MISC&#39;], id=None), length=-1, id=None)</code></pre>
<p>Yet again we have more custom classes straight from the <code>datasets</code> library. These will be useful if you‚Äôre converting over to this format manually. So, we have a <code>Sequence</code> of <code>ClassLabels</code>. For our purposes this is largely what it says on the tin. Each of the integer values in the <code>ner_tags</code> feature corresponds to these labels.</p>
<p>As for the labels themselves, what do they mean? What are the prefixes?</p>
</div>
<div id="ner-label-formats" class="section level2">
<h2>NER Label Formats</h2>
<p><strong>IOB</strong></p>
<p>There are many ways to format a dataset for NER, and, recall from the docs that our ‚Äúdataset uses IOB2 tagging scheme‚Äù. IOB stands for ‚Äúinside, outside, beginning‚Äù and refers to the prefixes in those labels. Quoting the <a href="https://huggingface.co/docs/transformers/tasks/token_classification">&lt;huggingface token classification tutorial&gt;</a>:</p>
<blockquote>
<pre><code>B - indicates the *beginning* of an entity.
I - indicates a token is contained *inside* the same entity.
0 - indicates the token doesn‚Äôt correspond to any entity. It is *outside* our entity list.</code></pre>
</blockquote>
<p>To elaborate further let‚Äôs use an example.</p>
<pre><code>string: &quot;Jane Doe went to Sega headquarters&quot;
tokens: [&quot;Jane&quot;, &quot;Doe&quot;, &quot;went&quot; &quot;to&quot;, &quot;Sega&quot;, &quot;headquarters&quot;]
translated ner_tags: [&quot;B-PER&quot;, &quot;I-PER&quot;, &quot;O&quot;, &quot;O&quot;, &quot;B-ORG&quot;, &quot;O&quot;]</code></pre>
<p>Jane Doe is a persons name that is split into two tokens. So each token is represented with their own label. Note that if Jane had 5 names instead of just a last name, each of those names would also have the ‚ÄúI-PER‚Äù label. The next two words are labeled ‚ÄúO‚Äù as they‚Äôre just words, not entities. Then ‚ÄúSega‚Äù is given a ‚ÄúB-ORG‚Äù label as its an organization and ‚ÄúB-‚Äù is also used for single word entities.</p>
<div id="quick-glimpse-at-other-common-formats" class="section level3">
<h3>Quick glimpse at other common formats:</h3>
<p><strong>BILUO</strong></p>
<p>This one stands for ‚Äúbeginning, inside, last, unit, outside‚Äù which is very similar to iob but with two new labels. ‚ÄúL-‚Äù is for the end of an entity. So ‚ÄúDoe‚Äù in our example would be ‚ÄúL-PER‚Äù. ‚ÄúU-‚Äù is for single token entities. So ‚ÄúSega‚Äù would be ‚ÄúU-ORG‚Äù in our example.</p>
<p><strong>Offsets</strong></p>
<p>This one is quite different and uses index spans to specify entity locations. We don‚Äôt use tokens here as we use string indices so we use the full string. The format is <code>[(start_index, end_index, entity_name), (start_index, end_index, entity_name), ...]</code></p>
<pre><code>string: &quot;Jane Doe went to Sega headquarters&quot;
offsets labels: [(0, 8, &quot;PER&quot;), (17, 21, &quot;ORG&quot;)]</code></pre>
<p>There are others, but these are what I have exposure to. None are strictly better than the other and different frameworks or models will expect different formats. So be prepared for that. Anyway, moving on.</p>
</div>
</div>
<div id="wait-my-data-doesnt-look-like-yours" class="section level2">
<h2>Wait, my data doesn‚Äôt look like yours!</h2>
<p>That‚Äôs expected. I‚Äôm working with a demo dataset after all. If you need to convert over to the <code>datasets</code> format there is yet another place hidden in the docs that serves as a good guide. The <a href="https://huggingface.co/docs/evaluate/v0.4.0/en/package_reference/evaluator_classes#evaluate.TokenClassificationEvaluator">&lt;docs for the model evaluator&gt;</a> feature a fantastic template for converting over. There are multiple functions to convert from various formats while making use of the classes I mentioned above.</p>
<p><img src="images/dataset_conversion.png" /></p>
<p>While this image is for stuff the evaluator is okay with, it‚Äôs actually a great demo of converting and is what I used when I first learned how!</p>
<p>Depending on how your data was labeled, you may need to convert between formats beforehand. If you‚Äôre using a pandas dataframe there are also functions to go from that to a dataset as well. That‚Äôs a little outside the scope of this write up unfortunately but I wanted to give you a jumping off point at least.</p>
<p>Now, actually moving on, we‚Äôre going to remove the features we don‚Äôt care about and extract out the names of our labels. We‚Äôll need them later.</p>
<pre><code>label_list = dataset[&quot;train&quot;].features[&quot;ner_tags&quot;].feature.names
dataset = dataset.remove_columns([&#39;pos_tags&#39;, &#39;chunk_tags&#39;])</code></pre>
</div>
<div id="tokenizing-the-data" class="section level2">
<h2>Tokenizing the Data</h2>
<p>The data seems to already be tokenized but it isn‚Äôt completely. It‚Äôs been split up, yes, but different models require subtly different formats for their tokenized data. So we‚Äôll be throwing our data through the pretrained tokenizer that is built for the model we‚Äôll be using, <code>distilbert-base-uncased</code>.</p>
<pre><code>from transformers import AutoTokenizer

model_name = &quot;distilbert-base-uncased&quot;
tokenizer = AutoTokenizer.from_pretrained(model_name)</code></pre>
<div id="example-tokenization" class="section level3">
<h3>Example Tokenization</h3>
<pre><code>In:

example_row = dataset[&quot;train&quot;][0]
tokenized_input = tokenizer(example_row[&quot;tokens&quot;], is_split_into_words=True)
tokens = tokenizer.convert_ids_to_tokens(tokenized_input[&quot;input_ids&quot;])
print(f&quot;Original Tokens: {example_row[&#39;tokens&#39;]}&quot;)
print(f&quot;Updated Tokens: {tokens}&quot;)</code></pre>
<pre><code>Out:

Original Tokens: [
  &#39;The&#39;, &#39;Bradys&#39;, &#39;walked&#39;, &#39;on&#39;, &#39;to&#39;, &#39;the&#39;, &#39;stage&#39;, &#39;,&#39;, &#39;he&#39;, &#39;on&#39;, &#39;her&#39;, &#39;arm&#39;, &#39;and&#39;, &#39;with&#39;, &#39;the&#39;,
  &#39;aid&#39;, &#39;of&#39;, &#39;a&#39;, &#39;cane&#39;, &#39;,&#39;, &#39;to&#39;, &#39;a&#39;, &#39;rousing&#39;, &#39;reception&#39;, &#39;from&#39;, &#39;the&#39;, &#39;convention&#39;, &#39;.&#39;
]
Updated Tokens: [
  &#39;[CLS]&#39;, &#39;the&#39;, &#39;brady&#39;, &#39;##s&#39;, &#39;walked&#39;, &#39;on&#39;, &#39;to&#39;, &#39;the&#39;, &#39;stage&#39;, &#39;,&#39;, &#39;he&#39;, &#39;on&#39;, &#39;her&#39;, &#39;arm&#39;, &#39;and&#39;, &#39;with&#39;, 
  &#39;the&#39;, &#39;aid&#39;, &#39;of&#39;, &#39;a&#39;, &#39;cane&#39;, &#39;,&#39;, &#39;to&#39;, &#39;a&#39;, &#39;ro&#39;, &#39;##using&#39;, &#39;reception&#39;, &#39;from&#39;, &#39;the&#39;, &#39;convention&#39;, &#39;.&#39;, &#39;[SEP]&#39;
]</code></pre>
<p>Some notes: First, notice the new tokens. <code>[CLS]</code> and <code>[SEP]</code>. These are special tokens that indicate the start and end of a string. Secondly, you may notice all of our text is now lowercase aside from the special tokens. That‚Äôs due to our model being an ‚Äúuncased‚Äù variant. This helps with the models size as it has to work with less overall characters. Lastly, we have way more tokens now. ‚Äúrousing‚Äù for instance has been broken up into two tokens. This is due to berts ‚Äúsubword tokenization‚Äù which breaks up words into more manageable ‚Äúsubwords‚Äù. Again, this is for space and efficiency.</p>
<p>Of note here is that we don‚Äôt have more ner tags to compensate for the new tokens. If we tried to use those tags they‚Äôd be misaligned and incorrect. Thankfully the folks over at huggingface provide us with a function to help realign our labels.</p>
</div>
<div id="applying-tokenizer-and-realigning-labels" class="section level3">
<h3>Applying Tokenizer and Realigning Labels</h3>
<p>This function can be found in its original form <a href="https://huggingface.co/docs/transformers/tasks/token_classification">&lt;in the token classification tutorial&gt;</a>.</p>
<pre><code>from transformers import PreTrainedTokenizer

def tokenize_and_align_labels(examples, tokenizer: PreTrainedTokenizer, label_all_word_parts: bool=False):
    
    tokenized_inputs = tokenizer(examples[&quot;tokens&quot;], truncation=True, is_split_into_words=True)

    labels = []
    for i, label in enumerate(examples[f&quot;ner_tags&quot;]):
        word_ids = tokenized_inputs.word_ids(batch_index=i)  # Map tokens to their respective word.
        previous_word_idx = None
        label_ids = []
        for word_idx in word_ids:  # Set the special tokens to -100.
            if word_idx is None:
                label_ids.append(-100)
            # Default behavior only labels the first token of a given word
            # But sometimes you may want to label all the word parts for very specific use cases.
            elif label_all_word_parts or (word_idx != previous_word_idx):
                label_ids.append(label[word_idx])
            else:
                label_ids.append(-100)
            previous_word_idx = word_idx
        labels.append(label_ids)

    tokenized_inputs[&quot;labels&quot;] = labels
    return tokenized_inputs</code></pre>
<p>This function makes a few specific calls that I think are worth pointing out. Let‚Äôs look at the link I provided.</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Mapping all tokens to their corresponding word with the word_ids method.</li>
<li>Assigning the label -100 to the special tokens [CLS] and [SEP] so they‚Äôre ignored by the PyTorch loss function (see CrossEntropyLoss).</li>
<li>Only labeling the first token of a given word. Assign -100 to other subtokens from the same word.</li>
</ol>
</blockquote>
<p>Number 3 is worth calling out here. This functionality is something you may not want if you‚Äôre working with weird non-traditional data. Say, like transaction strings that can be really messy and non-grammatical. In some niche cases labeling all the word parts can be advantageous so I add in an option for that here.</p>
<p>So, now we apply this function to our dataset.</p>
<pre><code>In: 
tokenized_ds = dataset.map(
    lambda examples: tokenize_and_align_labels(examples, tokenizer=tokenizer),
    batched=True
)

tokenized_ds</code></pre>
<pre><code>Out:
DatasetDict({
    train: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;ner_tags&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;, &#39;labels&#39;],
        num_rows: 7020
    })
    validation: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;ner_tags&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;, &#39;labels&#39;],
        num_rows: 3250
    })
    test: Dataset({
        features: [&#39;id&#39;, &#39;tokens&#39;, &#39;ner_tags&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;, &#39;labels&#39;],
        num_rows: 3453
    })
})</code></pre>
<p>Wow, that‚Äôs a lot of new features. Let‚Äôs check out an example row. It‚Äôs gonna be a messy one, bear with me.</p>
<pre><code>In:
import numpy as np
example = tokenized_ds[&#39;train&#39;][0]

print(example.keys())
print(f&quot;input_ids: {example[&#39;input_ids&#39;]}&quot;)
print(f&quot;labels: {example[&#39;labels&#39;]}&quot;)
print(f&quot;attention: {example[&#39;attention_mask&#39;]}&quot;)
decoded_ids = [tokenizer.decode(id) for id in example[&quot;input_ids&quot;]]
translated_labels = [label_list[label] if label != -100 else label for label in example[&#39;labels&#39;]]
print(&quot;\ntranslated ids and labels:&quot;)
for i in np.arange(len(example[&#39;input_ids&#39;])):
    print(decoded_ids[i], translated_labels[i])</code></pre>
<pre><code>Out:
dict_keys([&#39;id&#39;, &#39;tokens&#39;, &#39;ner_tags&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;, &#39;labels&#39;])
input_ids: [101, 1996, 10184, 2015, 2939, 2006, 2000, 1996, 2754, 1010, 2002, 2006, 2014, 2849, 1998, 2007, 1996, 4681, 1997, 1037, 11942, 1010, 2000, 1037, 20996, 18161, 7684, 2013, 1996, 4680, 1012, 102]
labels: [-100, 0, 1, -100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100, 0, 0, 0, 0, 0, -100]
attention: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

translated ids and labels:
[CLS] -100
the O
brady B-PER
##s -100
walked O
on O
to O
the O
stage O
, O
he O
on O
her O
arm O
and O
with O
the O
aid O
of O
a O
cane O
, O
to O
a O
ro O
##using -100
reception O
from O
the O
convention O
. O
[SEP] -100</code></pre>
<p>Let‚Äôs demystify the new stuff.</p>
<ul>
<li>input_ids: Tokens translated to numbers by the tokenizer.</li>
<li>attention mask: Does the model pay attention to this token or not? You get 0s here when you start adding padding. A 0 simply means that token will be ignored during training. We haven‚Äôt used padding so there aren‚Äôt any 0s here.</li>
<li>labels: updated ner_tags to accommodate special tokens</li>
</ul>
<p>It‚Äôs important to translate these numbers back to words so we can verify stuff is working as anticipated. Whenever stuff is changed you need to be confident it was changed correctly.</p>
</div>
<div id="sanity-checks" class="section level3">
<h3>Sanity Checks</h3>
<p>What would be bad are inequalities in length for features here. For example, if input_ids has a different length than labels this would break the training process and potentially indicate some deeper issues. Quick note</p>
<ul>
<li>tokens and ner_tags should be of equal length</li>
<li>All the new features should be of equal length</li>
</ul>
<p>Let‚Äôs look at a few rows and see if this seems to check out. I‚Äôll spare you the input here.</p>
<pre><code>Out:

Tokens Length: 28
NER Tags Length: 28
Input IDs Length: 32
Attention Mask Length: 32
Labels Length: 32

Tokens Length: 21
NER Tags Length: 21
Input IDs Length: 28
Attention Mask Length: 28
Labels Length: 28

Tokens Length: 8
NER Tags Length: 8
Input IDs Length: 12
Attention Mask Length: 12
Labels Length: 12

Tokens Length: 9
NER Tags Length: 9
Input IDs Length: 11
Attention Mask Length: 11
Labels Length: 11

Tokens Length: 20
NER Tags Length: 20
Input IDs Length: 24
Attention Mask Length: 24
Labels Length: 24</code></pre>
<p>Quick check seems fine. The old features are the same length and the new features all match as well. I‚Äôd recommend a more thorough check but this is just for the sake of demonstration so I‚Äôm allowed to be lazy. ü§∑</p>
<p>Now it‚Äôs time to get into the meat of this operation!</p>
</div>
</div>
</div>
<div id="building-the-trainer" class="section level1">
<h1>Building the Trainer</h1>
<p>So, we have the following left to setup for the trainer.</p>
<ul>
<li>A data collator</li>
<li>A model initialization function</li>
<li>A hyperparameter space</li>
<li>Training arguments</li>
<li>A function for computing metrics</li>
<li>id2label dictionary</li>
</ul>
<p>This will go a lot quicker.</p>
<div id="imports" class="section level2">
<h2>Imports</h2>
<pre><code>from transformers import (
    DataCollatorForTokenClassification, 
    AutoModelForTokenClassification, 
    TrainingArguments, 
    Trainer, 
    EarlyStoppingCallback
)
import evaluate
import numpy as np</code></pre>
</div>
<div id="data-collator" class="section level2">
<h2>Data Collator</h2>
<p><a href="https://huggingface.co/docs/transformers/main_classes/data_collator">&lt;Documentation&gt;</a></p>
<p>This lad is in charge of all things batches. They‚Äôre also capable of doing batch padding as well, and that will be necessary here.</p>
<pre><code>data_collator = DataCollatorForTokenClassification(tokenizer=tokenizer)</code></pre>
</div>
<div id="evaluator-compute_metrics-function" class="section level2">
<h2>Evaluator: compute_metrics function</h2>
<p>This object handles how model performance is calculated during training. You can manually create whatever metrics you like and use those to optimize the model. I‚Äôll yet again be deferring to the tutorial and using their function. Note that as your problem gets more and more niche that you‚Äôll want to consider writing this one yourself. These basic metrics or how they‚Äôre computed may not fit your needs.</p>
<p>Note that this function utilizes <code>seqeval</code> and I recommend reading up on how it classifies true/false predictions so you can properly interpret results.</p>
<p><a href="https://huggingface.co/spaces/evaluate-metric/seqeval">&lt;Seqeval Docs&gt;</a></p>
<pre><code>import evaluate
seqeval = evaluate.load(&quot;seqeval&quot;)

# Note: Uses the label_list we created earlier
def compute_metrics(p):
    predictions, labels = p
    predictions = np.argmax(predictions, axis=2)

    true_predictions = [
        [label_list[p] for (p, l) in zip(prediction, label) if l != -100]
        for prediction, label in zip(predictions, labels)
    ]
    true_labels = [
        [label_list[l] for (p, l) in zip(prediction, label) if l != -100]
        for prediction, label in zip(predictions, labels)
    ]

    results = seqeval.compute(predictions=true_predictions, references=true_labels)
    return {
        &quot;precision&quot;: results[&quot;overall_precision&quot;],
        &quot;recall&quot;: results[&quot;overall_recall&quot;],
        &quot;f1&quot;: results[&quot;overall_f1&quot;],
        &quot;accuracy&quot;: results[&quot;overall_accuracy&quot;],
    }</code></pre>
</div>
<div id="id-and-label-maps" class="section level2">
<h2>Id and Label Maps</h2>
<p>We need both directions of this map for our trainer. Nothing complex here, just a number -&gt; label dictionary.</p>
<pre><code>In:
label2id = {label: index for index, label in enumerate(label_list)}
id2label = {value: key for key, value in label2id.items()}

print(f&quot;label2id: {label2id}&quot;)
print(f&quot;id2label: {id2label}&quot;)</code></pre>
<pre><code>Out: 
label2id: {&#39;O&#39;: 0, &#39;B-PER&#39;: 1, &#39;I-PER&#39;: 2, &#39;B-ORG&#39;: 3, &#39;I-ORG&#39;: 4, &#39;B-LOC&#39;: 5, &#39;I-LOC&#39;: 6, &#39;B-MISC&#39;: 7, &#39;I-MISC&#39;: 8}
id2label: {0: &#39;O&#39;, 1: &#39;B-PER&#39;, 2: &#39;I-PER&#39;, 3: &#39;B-ORG&#39;, 4: &#39;I-ORG&#39;, 5: &#39;B-LOC&#39;, 6: &#39;I-LOC&#39;, 7: &#39;B-MISC&#39;, 8: &#39;I-MISC&#39;}</code></pre>
</div>
<div id="model-initializer" class="section level2">
<h2>Model Initializer</h2>
<p>This step is only necessary if you‚Äôre using hyperparameter search using the built in trainer method. This allows us to initialize a new model between grid searches.</p>
<pre><code>def model_init():
    return AutoModelForTokenClassification.from_pretrained(
        model_name, 
        num_labels=len(id2label.keys()), 
        id2label=id2label, 
        label2id=label2id
    )</code></pre>
</div>
<div id="training-arguments" class="section level2">
<h2>Training Arguments</h2>
<p>Here we set some default behavior for training. Some of these metrics will be changed by grid training.</p>
<pre><code>training_args = TrainingArguments(
    output_dir=&quot;../models/holding_zone&quot;,
    learning_rate=2e-5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=16,
    num_train_epochs=5,
    weight_decay=0.01,
    logging_strategy=&quot;epoch&quot;,
    evaluation_strategy=&#39;epoch&#39;,
    metric_for_best_model=&quot;eval_loss&quot;,
    save_strategy=&quot;no&quot;,
    push_to_hub=False,
    remove_unused_columns=False
)</code></pre>
<p>Some notes here on choices I‚Äôve made.</p>
<ul>
<li>The learning rate is a good default for making sure fine tuning doesn‚Äôt completely kill the original model. A learning rate set too high is enough to make the model far worse than it did originally, so be careful here.</li>
<li>train/eval batch sizes: Here we have some hardware dependency. We want a batch size large enough that training doesn‚Äôt take ages, but also small enough that it doesn‚Äôt devour our VRAM on the GPU. 16 is tried and tested on my machine (8 gigs of VRAM) though I have enough VRAM to spare this likely could go higher. The maximum batch size will be influenced by max padding length if you set that in your tokenizer as well, as larger vectors take up more memory. Also of note that just because you can theoretically fit everything into a single batch, smaller subsets of the data help a model generalize better. As such, balance between time taken, VRAM limitations, and also not trying to go tooooo large.</li>
<li>Number of train epochs: This influences how many passes through the dataset we do during training. Say you have 160 rows and your batch size is 16, it‚Äôll take 10 batches to reach 1 epoch. I‚Äôm keeping a small epoch count purely for my own sanity. As this dataset is large and this is just a demo, I don‚Äôt want to lose my mind.</li>
<li>Weight decay is set to a standard default value. This is an important value that I honestly need to put some reading into properly understanding.</li>
<li>Logging and evaluation strategy specify that after every epoch it‚Äôll log its results and also test on the evaluation dataset.</li>
<li>metric for best model is set to eval_loss as I want to try and minimize that value to get the best model. This can also be changed to other metrics like ‚Äúaccuracy‚Äù or ‚Äúf1_score‚Äù.</li>
<li>save_strategy is set to false as this being true during grid search results in serious slowdown and even more serious storage space annihilation.</li>
<li>remove unused columns is set to false as it‚Äôs given me inconsistent and frustrating behavior in the past. I manually remove the unused columns instead. It will need to earn my trust later if I am to use it again.</li>
</ul>
</div>
<div id="make-the-trainer" class="section level2">
<h2>Make the Trainer</h2>
<p>Now we just plug all of our component pieces into the Trainer. I remove id, tokens and ner_tags from the dataset as I only want the post-tokenization columns to be used for training.</p>
<pre><code>trainer = Trainer(
    model=None,
    args=training_args,
    train_dataset=tokenized_ds[&quot;train&quot;].remove_columns([&quot;id&quot;, &quot;tokens&quot;, &quot;ner_tags&quot;]),
    eval_dataset=tokenized_ds[&quot;validation&quot;].remove_columns([&quot;id&quot;, &quot;tokens&quot;, &quot;ner_tags&quot;]),
    compute_metrics=compute_metrics,
    tokenizer=tokenizer,
    model_init=model_init,
    data_collator=data_collator
)</code></pre>
</div>
</div>
<div id="training-via-hyperparameter-search" class="section level1">
<h1>Training via Hyperparameter Search</h1>
<div id="hyperparameter-space" class="section level2">
<h2>Hyperparameter Space</h2>
<p>Here we‚Äôll be using the library <code>optuna</code> to setup a hyperparameter space we‚Äôll be doing a grid search on. Optuna in particular is helpful here as it is a free alternative to something like <code>weights and balances</code> which not all data scientists will have access to.</p>
<p>I‚Äôll be doing a very basic grid search just as a demonstration of how it‚Äôs done. Low number of epochs and a very small number of trials with basically arbitrary values for grid search. You‚Äôll want to tweak these to your needs.</p>
<p><a href="https://huggingface.co/docs/transformers/hpo_train">&lt;Huggingface docs on hyperparameter search&gt;</a>
<a href="https://optuna.org/">&lt;Optuna Link&gt;</a></p>
<pre><code>In:
import optuna

def optuna_hp_space(trial):
    return {
        &quot;learning_rate&quot;: trial.suggest_float(&quot;learning_rate&quot;, 2e-5, 5e-5, log=True),
        &quot;per_device_train_batch_size&quot;: trial.suggest_categorical(&quot;per_device_train_batch_size&quot;, [6, 8, 16]),
        &quot;per_device_eval_batch_size&quot;: trial.suggest_categorical(&quot;per_device_eval_batch_size&quot;, [6, 8, 16])
    }</code></pre>
</div>
<div id="hyperparameter-search" class="section level2">
<h2>Hyperparameter Search</h2>
<pre><code>In:
best_trial = trainer.hyperparameter_search(
    direction=&quot;minimize&quot;,
    backend=&quot;optuna&quot;,
    hp_space=optuna_hp_space,
    n_trials=3
)

best_trial</code></pre>
<p><img src="images/grid_search_output.png" /></p>
</div>
</div>
<div id="training-the-final-model" class="section level1">
<h1>Training the Final Model</h1>
<p>We now have the best parameters, so let‚Äôs train one last time. We‚Äôll need to set stuff up a little bit differently for the real deal.</p>
<p>For starters, we now want to save our model. Primarily, we‚Äôll now save checkpoints at each epoch, especially since we‚Äôll only do 5 epochs. I do early stopping here just to show how it‚Äôs used really.</p>
<p>The upsides of saving checkpoints is we can look at the training logs and pick out which checkpoint performed best and avoid overfitting.</p>
<pre><code>In:
training_args = TrainingArguments(
    output_dir=&quot;../models/holding_zone&quot;,
    learning_rate=best_parameters[&#39;learning_rate&#39;],
    per_device_train_batch_size=best_parameters[&#39;per_device_train_batch_size&#39;],
    per_device_eval_batch_size=best_parameters[&#39;per_device_eval_batch_size&#39;],
    num_train_epochs=5,
    weight_decay=0.01,
    logging_strategy=&quot;epoch&quot;,
    evaluation_strategy=&#39;epoch&#39;,
    metric_for_best_model=&quot;eval_loss&quot;,
    push_to_hub=False,
    remove_unused_columns=False,
    save_strategy=&quot;epoch&quot;,
    save_total_limit=5,
    load_best_model_at_end=True
)

trainer = Trainer(
    model=None,
    args=training_args,
    train_dataset=tokenized_ds[&quot;train&quot;].remove_columns([&quot;id&quot;, &quot;tokens&quot;, &quot;ner_tags&quot;]),
    eval_dataset=tokenized_ds[&quot;validation&quot;].remove_columns([&quot;id&quot;, &quot;tokens&quot;, &quot;ner_tags&quot;]),
    compute_metrics=compute_metrics,
    tokenizer=tokenizer,
    model_init=model_init,
    data_collator=data_collator,
    callbacks = [EarlyStoppingCallback(early_stopping_patience=3)]
)

trainer.train()</code></pre>
<p><img src="images/training_output.png" /></p>
<div id="training-evaluation" class="section level2">
<h2>Training Evaluation</h2>
<p>Let‚Äôs pretend we didn‚Äôt have only 5 epochs and needed to gauge how this performed. We can utilize the training logs to create some dataframes and visualizations!</p>
<div id="creating-log-dataframe" class="section level3">
<h3>Creating Log Dataframe</h3>
<pre><code>In:
import pandas as pd

train_logs = []
valid_logs = []
for index, x in enumerate(trainer.state.log_history):
    if &#39;loss&#39; in x.keys():
        train_logs.append(x)
    elif &#39;eval_loss&#39; in x.keys():
        valid_logs.append(x)
    else:
        pass

train_logs = pd.DataFrame(train_logs)
valid_logs = pd.DataFrame(valid_logs)
logs = train_logs.merge(valid_logs, on=[&quot;epoch&quot;, &quot;step&quot;])

display(logs)</code></pre>
<p><img src="images/training_logs.png" /></p>
</div>
<div id="visualizing-logs" class="section level3">
<h3>Visualizing Logs</h3>
<p><img src="images/loss_plot.png" /></p>
<p><img src="images/validation_metrics_plot.png" /></p>
<p>We‚Äôll go with epoch 2 as the metrics are perfectly high there and I want to avoid any potential overfitting from epochs 3 and on. Hard to gauge if it‚Äôs genuinely overfitting due to the small number of epochs and how small all the loss scores are, but we‚Äôll play it safe.</p>
</div>
</div>
</div>
<div id="using-the-model-finally" class="section level1">
<h1>Using the Model (Finally)</h1>
<div id="building-the-pipeline" class="section level2">
<h2>Building the Pipeline</h2>
<p>Pipelines are great when you can use them. Normally when you run predictions they‚Äôre done on each and every token and require some cleanup, but pipelines handle prediction aggregation for you and provide some really clean output.</p>
<pre><code>from transformers import pipeline

checkpoint = 1756 # Checkpoint for epoch 2.
model_dir = f&quot;../models/holding_zone/checkpoint-{checkpoint}&quot;
model = AutoModelForTokenClassification.from_pretrained(model_dir)
tokenizer = AutoTokenizer.from_pretrained(model_dir)
aggregation_strategy = &quot;average&quot;
pipe = pipeline(
    task=&quot;token-classification&quot;, model=model, tokenizer=tokenizer, aggregation_strategy=aggregation_strategy
)</code></pre>
<p>Here we‚Äôll run some predictions and add some extra information for context. The dictionaries at the bottom are the real output of the pipeline.</p>
<pre><code>In:
for index, row in enumerate(tokenized_ds[&quot;test&quot;]):
    if index &lt; 5:
        text = &quot; &quot;.join(row[&quot;tokens&quot;])
        othertags = [id2label[id] for id in row[&quot;ner_tags&quot;]]
        
        # Note that this is the only line you actually need to use the pipe. The rest is for context.
        pipe_output = pipe(text)
        
        print(f&quot;Row: {index}&quot;)
        print(f&quot;Transaction: {text}&quot;)
        print(f&quot;Actual NER tags: {othertags}&quot;)
        for output in pipe_output:
            print(output)
        print(&quot;\n&quot;)</code></pre>
<pre><code>Out:
Row: 0
Transaction: SOCCER - JAPAN GET LUCKY WIN , CHINA IN SURPRISE DEFEAT .
Actual NER tags: [&#39;O&#39;, &#39;O&#39;, &#39;B-LOC&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-PER&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.99867, &#39;word&#39;: &#39;japan&#39;, &#39;start&#39;: 9, &#39;end&#39;: 14}
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.99866974, &#39;word&#39;: &#39;china&#39;, &#39;start&#39;: 31, &#39;end&#39;: 36}


Row: 1
Transaction: Nadim Ladki
Actual NER tags: [&#39;B-PER&#39;, &#39;I-PER&#39;]
{&#39;entity_group&#39;: &#39;PER&#39;, &#39;score&#39;: 0.89792097, &#39;word&#39;: &#39;nadim ladki&#39;, &#39;start&#39;: 0, &#39;end&#39;: 11}


Row: 2
Transaction: AL-AIN , United Arab Emirates 1996-12-06
Actual NER tags: [&#39;B-LOC&#39;, &#39;O&#39;, &#39;B-LOC&#39;, &#39;I-LOC&#39;, &#39;I-LOC&#39;, &#39;O&#39;]
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.95205337, &#39;word&#39;: &#39;al - ain&#39;, &#39;start&#39;: 0, &#39;end&#39;: 6}
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.99500734, &#39;word&#39;: &#39;united arab emirates&#39;, &#39;start&#39;: 9, &#39;end&#39;: 29}


Row: 3
Transaction: Japan began the defence of their Asian Cup title with a lucky 2-1 win against Syria in a Group C championship match on Friday .
Actual NER tags: [&#39;B-LOC&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-MISC&#39;, &#39;I-MISC&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-LOC&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.9985221, &#39;word&#39;: &#39;japan&#39;, &#39;start&#39;: 0, &#39;end&#39;: 5}
{&#39;entity_group&#39;: &#39;MISC&#39;, &#39;score&#39;: 0.98925483, &#39;word&#39;: &#39;asian cup&#39;, &#39;start&#39;: 33, &#39;end&#39;: 42}
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.9985801, &#39;word&#39;: &#39;syria&#39;, &#39;start&#39;: 78, &#39;end&#39;: 83}


Row: 4
Transaction: But China saw their luck desert them in the second match of the group , crashing to a surprise 2-0 defeat to newcomers Uzbekistan .
Actual NER tags: [&#39;O&#39;, &#39;B-LOC&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-LOC&#39;, &#39;O&#39;]
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.9985563, &#39;word&#39;: &#39;china&#39;, &#39;start&#39;: 4, &#39;end&#39;: 9}
{&#39;entity_group&#39;: &#39;LOC&#39;, &#39;score&#39;: 0.9988122, &#39;word&#39;: &#39;uzbekistan&#39;, &#39;start&#39;: 119, &#39;end&#39;: 129}</code></pre>
<p>Alright, now we can use the model. But how good is it really? Some of these predictions are good, others aren‚Äôt, but eyeballing this stuff is always a terrible idea. Let‚Äôs break out an evaluator.</p>
</div>
</div>
<div id="test-split-evaluation" class="section level1">
<h1>Test Split Evaluation</h1>
<p>Here out setup is a bit different from building a trainer. We remake the pipe without aggregation as that can sometimes cause issues. We also allow the evaluator to convert our tokens into a full string. Nothing too crazy.</p>
<pre><code>In:
from evaluate import evaluator

task_evaluator = evaluator(&quot;token-classification&quot;)
pipe = pipeline(
    task=&quot;token-classification&quot;, model=model, tokenizer=tokenizer
)

results = task_evaluator.compute(
    model_or_pipeline=pipe,
    data=tokenized_ds[&quot;test&quot;],
    metric=&quot;seqeval&quot;,
    input_column=&quot;tokens&quot;,
    label_column=&quot;ner_tags&quot;,
    join_by=&quot; &quot;
)
results</code></pre>
<pre><code>Out:
{&#39;LOC&#39;: {&#39;precision&#39;: 0.9088182363527294,
  &#39;recall&#39;: 0.908273381294964,
  &#39;f1&#39;: 0.9085457271364317,
  &#39;number&#39;: 1668},
 &#39;MISC&#39;: {&#39;precision&#39;: 0.7337837837837838,
  &#39;recall&#39;: 0.7735042735042735,
  &#39;f1&#39;: 0.753120665742025,
  &#39;number&#39;: 702},
 &#39;ORG&#39;: {&#39;precision&#39;: 0.8,
  &#39;recall&#39;: 0.8741721854304636,
  &#39;f1&#39;: 0.8354430379746836,
  &#39;number&#39;: 1661},
 &#39;PER&#39;: {&#39;precision&#39;: 0.9592986850344396,
  &#39;recall&#39;: 0.9474335188620903,
  &#39;f1&#39;: 0.9533291848164281,
  &#39;number&#39;: 1617},
 &#39;overall_precision&#39;: 0.8664719023887266,
 &#39;overall_recall&#39;: 0.8927053824362606,
 &#39;overall_f1&#39;: 0.8793930408999738,
 &#39;overall_accuracy&#39;: 0.9754926240982018,
 &#39;total_time_in_seconds&#39;: 85.87057160699987,
 &#39;samples_per_second&#39;: 40.21168061863144,
 &#39;latency_in_seconds&#39;: 0.024868396063423073}</code></pre>
<p>Oh god that‚Äôs a lot of stuff. Kinda makes your eyes glaze over huh? Let me clean this up.</p>
<p><img src="images/evaluation_output.png" /></p>
<p>And some quick visualizations to go with it!</p>
<p>First I‚Äôll show the performance per entity, then I‚Äôll show how frequent each entity type is. The second plot I highly recommend examining as, especially in smaller datasets, not all entities will be as frequent as you may like. A smaller frequency of entities may result in the model giving extreme results for their metrics. Remember to not take metric results at face value.</p>
<p><img src="images/testing_metrics_plot.png" /></p>
<p><img src="images/entity_frequency_plot.png" /></p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>And that‚Äôs that really! This was a LONG writeup so thanks for sticking to the end. We covered a lot here so I hope even a fraction of the information presented was helpful.</p>
<p>Next up, we‚Äôll be solving the problem of this model being stuck on your machine. We‚Äôll be talking deployment!</p>
</div>
